#!/usr/bin/env bun

/**
 * Generate index.ts that exports all generated proto types
 */

import { readdirSync, writeFileSync, readFileSync } from 'fs';
import { join } from 'path';

const generatedDir = join(import.meta.dir, '..', 'src', 'generated');
const indexPath = join(generatedDir, 'index.ts');

try {
  const files = readdirSync(generatedDir)
    .filter(f => f.endsWith('.ts') && f !== 'index.ts')
    .map(f => f.replace('.ts', ''));

  // Track exported names to avoid duplicates
  const seenNames = new Set<string>();

  // Extract exported types from each file to create selective exports
  const exports = files
    .map(file => {
      const filePath = join(generatedDir, `${file}.ts`);
      const content = readFileSync(filePath, 'utf-8');

      // Extract interface, enum, and type names (avoid utility types)
      const exportedInterfaces: string[] = [];
      const exportedEnums: string[] = [];
      const exportedTypes: string[] = [];

      const interfaceMatches = content.matchAll(/export interface (\w+)/g);
      const enumMatches = content.matchAll(/export enum (\w+)/g);
      const typeMatches = content.matchAll(/export type (\w+)/g);

      for (const match of interfaceMatches) {
        const name = match[1];
        if (!seenNames.has(name)) {
          exportedInterfaces.push(name);
          seenNames.add(name);
        }
      }
      for (const match of enumMatches) {
        const name = match[1];
        if (!seenNames.has(name)) {
          exportedEnums.push(name);
          seenNames.add(name);
        }
      }
      for (const match of typeMatches) {
        const name = match[1];
        // Skip utility types
        if (!['DeepPartial', 'MessageFns', 'Builtin'].includes(name) && !seenNames.has(name)) {
          exportedTypes.push(name);
          seenNames.add(name);
        }
      }

      const allExports = [...exportedInterfaces, ...exportedEnums, ...exportedTypes];

      if (allExports.length === 0) {
        return null;
      }

      // Use 'export type' for types to satisfy isolatedModules
      return `export type {\n  ${allExports.join(',\n  ')}\n} from './${file}';`;
    })
    .filter(Boolean)
    .join('\n\n');

  const content = `/**
 * Generated protobuf types
 *
 * This file is auto-generated by scripts/generate-index.ts
 * Do not edit manually
 */

${exports}
`;

  writeFileSync(indexPath, content);
  console.log(`âœ“ Generated ${indexPath}`);
  console.log(`  Exported: ${files.join(', ')}`);
} catch (error) {
  console.error('Failed to generate index:', error);
  process.exit(1);
}
